# piecewiseLinFit

## 语法

`piecewiseLinFit(X, Y, numSegments, [XC], [YC], [bounds],
[lapackDriver='gelsd'], [degree=1], [weights], [method='de'], [maxIter],
[initialGuess], [seed])`

## 详情

通过给定数据点集和给定线段数，拟合一个连续的分段线性回归函数；并使用差分进化算法通过最小化平方误差之和，找到给定数量的线段断点的最优位置。

注意：由于差分进化算法的随机性，本函数每次运行结果会略有区别。

## 参数

**X** 数值向量，表示数据点的 x 坐标值。仅在 *method*='de' 时生效。注意：不可传入 NULL 值。

**Y** 数值向量，表示数据点的 y 坐标值。仅在 *method*='de' 时生效。注意：不可传入 NULL 值。

**numSegments** 正整数，表示用于拟合的线段数量。

**XC** 可选参数，数值向量，表示分段线性函数将被强制通过的数据点的 x 位置。

**YC** 可选参数，数值向量，表示分段线性函数将被强制通过的数据点的 y 位置。

**bounds** 可选参数，数值矩阵，表示在优化中每个断点位置的边界。形状为(numSegments - 1, 2)，每一行为对应断点的边界。

**lapackDriver** 可选参数，字符串标量，表示使用具体的某个 LAPACK 程序来求解最小二乘问题。可选值为'gelsd', 'gelsy' 和
'gelss'。

**degree** 可选参数，非负整数标量，表示要使用的多项式的阶数。degree=1 表示使用线性模型；degree=0 表示使用常数模型。

**weights**可选参数，数值向量，表示加权最小二乘法中的权重。单个权重通常是每个数据点标准偏差的倒数，即 *weights[i]* 为第 i
个数据点标准差的倒数。注意：不可传入 NULL 值。

**method** 可选参数，字符串标量，表示在拟合过程中使用的最优化算法。可选值为：

* “nm“：表示使用 Nelder-Mead 单纯形算法。
* “bfgs“：表示使用 bfgs 算法。
* “lbfgs“ ：表示使用 lbfgs 算法。
* 'slsqp'：表示顺序最小二乘编程方法（SLSQP）算法。
* 'de'：表示差分进化(Differential Evolution)算法，默认值。

**maxIter** 可选参数，整型标量或向量，表示拟合过程中优化算法的最大迭代次数。

**initialGuess** 可选参数，数值向量，表示分段断点位置的初始猜测，长度为 *numSegments* - 1。

**seed** 可选参数，整数标量，表示差分进化算法中使用的随机数种子，仅在 *method*='de' 或 *initialGuess*
为空时生效。若 *method*='de' 或 *initialGuess* 为空，且不指定
*seed*，则采用非确定性的随机数生成器。*seed* 参数用于确保结果的可复现性。

## 返回值

返回一个字典，字典有以下成员：

* breaks：浮点数向量，表示模型拟合后得到的线段断点位置。
* beta：浮点数向量，表示模型拟合后的参数值。
* xData：浮点数向量，表示输入的数据点的 x 坐标值。
* yData：浮点数向量，表示输入的数据点的 y 坐标值。
* XC：浮点数向量，表示分段线性函数将被强制通过的数据点的 x 位置。
* YC：浮点数向量，表示分段线性函数将被强制通过的数据点的 y 位置。
* weights：浮点数向量，表示加权最小二乘法中的权重。
* degree：整数标量，表示要使用的多项式的阶数。
* lapackDriver：字符串标量，表示使用的具体 LAPACK 程序来求解最小二乘问题。
* numParameters：整数标量，表示模型的参数数量。
* predict：模型的预测函数。其使用方法为 `model.predict(X, [beta],
  [breaks])`，详情见 [pwlfPredict](pwlfpredict.md)。
* modelName：表示模型类型，值为字符串”Piecewise Linear Regression”。

## 例子

本例自定义条件，传入参数 *X*, *Y*, *numSegments*，拟合一个连续的分段线性回归函数，并找到 3
个线段断点的最优位置。

```
def linspace(start, end, num, endpoint=true){
	if(endpoint) return end$DOUBLE\(num-1), start + end$DOUBLE\(num-1)*0..(num-1)
	else return start + end$DOUBLE\(num-1)*0..(num-1)
}
X = linspace(0.0, 1.0, 10)[1]
Y = [0.41703981, 0.80028691, 0.12593987, 0.58373723, 0.77572962, 0.41156172, 0.72300284, 0.32559528, 0.21812564, 0.41776427]
model = piecewiseLinFit(X, Y, 3)
model;

/* Output:
breaks->[0.0,0.258454644769,0.366954310101,1.000000000000]
numParameters->4
degree->1
xData->[0.0,0.111111111111,0.222222222222,0.333333333333,0.444444444444,0.555555555555,0.666666666666,0.777777777777,0.888888888888,1.000000000000]
predict->pwlfPredict
yData->[0.417039810000,0.800286910000,0.125939870000,0.583737230000,0.775729620000,0.411561720000,0.723002840000,0.325595280000,0.218125640000,0.417764270000]
yC->
xC->
weights->
beta->[0.593305500750,-1.309949743583,5.703647584013,-5.105351630664]
lapackDriver->gelsd
*/
```

承接上例，`piecewiseLinFit` 也可结合函数 `pwlfPredict`
使用。如下自定义参数，使用拟合后的连续分段线性回归模型来对输入的数据点进行预测。

```
xHat = linspace(0.0, 1.0, 20)[1]
model.predict(xHat)

/* Output:
[0.593305499919518 0.524360777381737 0.455416054843957 0.386471332306177 0.317526609768396 0.368043438179296 0.529813781212159 0.691584124245021 0.69295837868457  0.655502915538459 0.618047452392347 0.580591989246236 0.543136526100125 0.505681062954014 0.468225599807903 0.430770136661792 0.393314673515681 0.35585921036957  0.318403747223459 0.280948284077348]
*/
```

相关函数：[pwlfPredict](pwlfpredict.md)

