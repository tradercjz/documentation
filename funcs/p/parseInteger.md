# parseInteger

## 语法

`parseInteger(X, type, [radix=10])`

别名：`parseInt`

## 参数

**X** 表示待转换的字符串，支持标量、矩阵、向量和数据对。

**type** 表示转换后的类型，支持 CHAR/SHORT/INT/LONG。

**radix** 表示基数，可选参数，有效范围为[2, 16]，默认为 10。如 *radix* 为2，那么 *X*
的“合法字符”就指{“0”, “1”}；*radix* 为11，那么”合法字符”就指[0, 9]和 A/a（不区分大小写）。特别的，如果
*radix* 为16，那么前导的”0x”或”0X”不会被认为非法字符。

## 详情

按照不同进制把字符串转换为指定的整数类型。该函数从 *X* 的第一个字符开始转换，直到遇到第一个非法字符，即返回此前的转换结果。当 X
为集合时，将输出相同类型的集合。

注意：

* 转换时会忽略前导空格和前导 0。
* 不支持转换小数，'.'字符属于非法字符。
* 如果（忽略前导空格后）字符串为空，则返回 NULL。
* 如果在遇到非法字符前没有遇到过合法字符，函数将抛出异常。
* 前导空格后的第一个字符可以为'+'/'-'以表示正/负语义，其余位置上的'+'/'-'为非法字符。

## 例子

以下给出几个简单示例。

```
parseInteger([" ", "000", "012", " 12","12a", "1a2","+12a", "-12"], INT)
//output: [ , 0, 12, 12, 12, 1, 12, -12]

parseInteger("a12", INT)
//Error: 'Invalid string to parse.'

parseInteger(["012", " 12","12a", "1a2","1A2", "-1A2"], INT, 11)
//output: [13, 13, 153, 233, 233, -233]

parseInteger(["0x16", "0X16"], INT)//output:[0, 0]

parseInteger(["0x16", "0X16"], INT, 16)//output:[22, 22]

parseInteger( "9" , INT, 8)
//Error: 'Invalid string to parse.'
```

