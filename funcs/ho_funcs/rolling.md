# rolling

## 语法

`rolling(func, funcArgs, window, [step=1])`

## 参数

* **func** 聚合函数或向量函数。若 *func* 是向量函数，则 *step*
  必须和 *window* 相等。
* **funcArgs** 函数 *func*
  的参数。可为向量或矩阵。如果有多个参数，则用元组表示，并且每个参数的长度（向量的元素个数或矩阵的行数）必须相同。
* **window** 滑动窗口长度。
* **step** 应用函数的频率。默认值为1。

## 详情

应用函数/运算符到给定对象的一个滑动窗口（ *step* 与 *window*
取相同值时为滚动窗口）上。

当第一个滑动窗口出现时，高阶函数开始计算，然后每经过 *step* 个元素就进行一次变量计算。

注：

* 当 *func* 指定为向量函数时，*window* 必须等于
  *step*。
* 若窗口内的元素个数小于窗口长度，则该窗口不会计算输出。

和 *moving* 高阶函数类似，即对矩阵来说滑动窗口还是按行计算，而其他高阶函数通常是按列计算。

`rolling` 的 *func* 支持向量函数和聚合函数，而
`moving` 的 *func* 只支持聚合函数。

*func* 为聚合函数时，`rolling` 与
`moving` 的区别是：

1. `rolling` 支持参数 *step*，可以指定窗口滑动的步长；而
   `moving` 的滑动步长只能是 1。
2. `rolling` 不输出前 *window* - 1 个 NULL
   值结果。

## 例子

*func* 为向量函数：

```
m = matrix(3 4 6 8 5 2 0 -2, 2 9 NULL 1 3 -4 2 1, NULL 8 9 8 0 1 9 -3)
rolling(cummax, m, 4, 4)
```

输出返回：

| col1 | col2 | col3 |
| --- | --- | --- |
| 3 | 2 |  |
| 4 | 9 | 8 |
| 6 | 9 | 9 |
| 8 | 9 | 9 |
| 5 | 3 | 0 |
| 5 | 3 | 1 |
| 5 | 3 | 9 |
| 5 | 3 | 9 |

```
rolling(cumsum, m, 3, 3)
```

输出返回：

| col1 | col2 | col3 |
| --- | --- | --- |
| 3 | 2 |  |
| 7 | 11 | 8 |
| 13 | 11 | 17 |
| 8 | 1 | 8 |
| 13 | 4 | 8 |
| 15 | 0 | 9 |

*func* 为聚合函数：

```
rolling(sum, m, 4)
```

输出返回：

| col1 | col2 | col3 |
| --- | --- | --- |
| 21 | 12 | 25 |
| 23 | 13 | 25 |
| 21 | 0 | 18 |
| 15 | 2 | 18 |
| 5 | 2 | 7 |

计算APPL相对于市场(SPY)的beta值，滑动窗口长度为10，频率为5。

```
date=2016.08.01..2016.08.31
date=date[1<=weekday(date)<=5]
aaplRet=0.0177 -0.0148 0.0125 0.0008 0.0152 0.0083 0.0041 -0.0074 -0.0006 0.0023 0.0120 -0.0009 -0.0015 -0.0013 0.0026 -0.0078 0.0031 -0.0075 -0.0043 -0.0059 -0.0011 -0.0077 0.0009
spyRet=-0.0008 -0.0064 0.0029 0.0011 0.0082 -0.0006 0.0006 -0.0025 0.0046 -0.0009 0.0029 -0.0052 0.0019 0.0022 -0.0015 0.0000 0.0020 -0.0051 -0.0007 -0.0019 0.0049 -0.0016 -0.0028
t=table(date, aaplRet, spyRet);
t;
```

输出返回：

| date | aaplRet | spyRet |
| --- | --- | --- |
| 2016.08.01 | 0.0177 | -0.0008 |
| 2016.08.02 | -0.0148 | -0.0064 |
| 2016.08.03 | 0.0125 | 0.0029 |
| 2016.08.04 | 0.0008 | 0.0011 |
| 2016.08.05 | 0.0152 | 0.0082 |
| 2016.08.08 | 0.0083 | -0.0006 |
| 2016.08.09 | 0.0041 | 0.0006 |
| 2016.08.10 | -0.0074 | -0.0025 |
| 2016.08.11 | -0.0006 | 0.0046 |
| 2016.08.12 | 0.0023 | -0.0009 |
| 2016.08.15 | 0.012 | 0.0029 |
| 2016.08.16 | -0.0009 | -0.0052 |
| 2016.08.17 | -0.0015 | 0.0019 |
| 2016.08.18 | -0.0013 | 0.0022 |
| 2016.08.19 | 0.0026 | -0.0015 |
| 2016.08.22 | -0.0078 | 0 |
| 2016.08.23 | 0.0031 | 0.002 |
| 2016.08.24 | -0.0075 | -0.0051 |
| 2016.08.25 | -0.0043 | -0.0007 |
| 2016.08.26 | -0.0059 | -0.0019 |
| 2016.08.29 | -0.0011 | 0.0049 |
| 2016.08.30 | -0.0077 | -0.0016 |
| 2016.08.31 | 0.0009 | -0.0028 |

```
// 计算滚动beta
betas = rolling(beta, [aaplRet, spyRet], 10,5);
dates = rolling(last, date, 10,5);
table(dates, betas);
```

输出返回：

| dates | betas |
| --- | --- |
| 2016.08.12 | 1.601173 |
| 2016.08.19 | 0.512656 |
| 2016.08.26 | 1.064465 |

生成一个带有行标签的矩阵 m，将其作为参数 *func*Args。

当传入参数 *func* 是一个聚合函数，输出带有行标签的结果矩阵。

```
minBar = 2024.03.08T10:00:00 + 0..9
aaplClose = [170.88,170.88,170.90,171.05,171.18,171.30,171.51,171.49,171.31,171.14]
ibmClose = [150.15,150.18,150.20,150.05,150.18,150.25,150.32,150.30,150.31,150.20]
m = matrix(aaplClose, ibmClose).rename!(minBar, `aapl`ibm)

// func 也支持传入自定义的聚合函数
rolling(func=avg, funcArgs=m, window=5, step=2)
```

输出结果：

|  |  |  |
| --- | --- | --- |
| label | aapl | ibm |
| 2024.03.08T10:00:00 | 170.978 | 150.152 |
| 2024.03.08T10:00:02 | 171.188 | 150.2 |
| 2024.03.08T10:00:04 | 171.358 | 150.272 |

承接上例，当传入参数 *func* 是一个部分应用，也可输出带有行标签的结果矩阵。

```
defg f1(x,y){
	return (last(x)-first(x))/size(x)+y
}
f2 = f1{,1}
rolling(func=f2, funcArgs=m, window=5, step=2)
```

输出结果：

|  |  |  |
| --- | --- | --- |
| label | aapl | ibm |
| 2024.03.08T10:00:00 | 1.06 | 1.006 |
| 2024.03.08T10:00:02 | 1.122 | 1.024 |
| 2024.03.08T10:00:04 | 1.026 | 1.026 |

