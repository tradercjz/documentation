# eachPre

## 语法

`eachPre(func, X, [pre], [assembleRule|consistent=false])`

`func:P([pre], X)` 或 `[pre] <operator>:P X` 表示不指定
*assembleRule*，使用默认值

`func:PC([pre], X)` 或 `[pre] <operator>:PC X` 表示指定
*assembleRule，*此例中指定为 C（Consistent）

## 参数

* **func** 是一个二元函数。
* **X**
  可以是向量、矩阵或表。当X是向量时，pre必须是标量；当X是矩阵时，pre必须是标量或向量；当X是表时，pre必须是标量或表；当pre未指定时，结果的第一个元素为NULL。
* **pre** 可选参数，用于为计算提供初始的前序值，其数据形式要求取决于 *X* 的数据形式。
* **assembleRule** 可选参数，表示如何将子任务的结果合并为函数最终结果。接受一个整数或字符串作为输入，可选值如下：
  + 0 （或 "D"）：默认值，表示 DolphinDB
    规则，即根据所有子任务的结果来决定最终输出的数据类型和形式。当所有子结果具有相同的数据类型和形式时，多个标量合并为一个向量、多个向量合并为一个矩阵、多个矩阵合并为一个元组、多个字典合并为一张表；否则将所有子结果合并为一个元组输出。
  + 1（或 "C"）：表示 Consistent
    规则，即认为所有子结果的数据类型和形式都与第一个子结果相同，根据第一个子结果来选择最终结果的数据类型和形式。如果后续子任务返回的结果与第一个子任务的结果类型不一致，系统会尝试对后续结果进行类型转换。如果转换失败则抛出异常。因此，此规则只可在已知子结果的数据类型及形式一致时指定。此规则可使系统免于逐一缓存并检查每个子任务的计算结果，从而提升性能。
  + 2（或 "U"）：表示 Tuple 规则，系统不再对各子结果的类型和形式一致性进行检查，而是直接将子结果组装成一个元组输出。
  + 3（或 "K"）：表示 kdb+ 规则。与 DolphinDB 规则类似，都会根据所有子结果来决定最终结果形式。主要区别在于，kdb+
    规则下，只要有任一子任务返回向量，则最终结果必为一个元组；而在 DolphinDB
    规则下，子任务结果若均为长度相同的向量，则最终结果为一个矩阵。其他情况下，kdb+ 规则的输出与 DolphinDB 规则相同。

  注：
  + 自 2.00.15/3.00.3 版本起，新增了
    *assembleRule* 参数。该参数不仅实现了原 *consistent*
    参数的功能，还提供了更多的结果合并选项。*consistent* 是一个布尔值，默认值为 false，相当于
    *assembleRule*="D"；若为 true，则相当于
    *assembleRule*="C"。为保持兼容性，用户仍可使用 *consistent* 参数。如果同时指定
    *assemble* 和 *consistent*，将以 *consistent*
    的值为准。
  + *assembleRule* 也可在高阶函数对应的函数模式符号后指定，通过字符 D/C/U/K 表示。以
    `eachPre (:P)` 为例，形如
    `sub:PU(X)`。不指定则使用默认值 D。

## 详情

将给定函数/运算符应用于X中所有相邻的数据对。

*eachPre* 高阶函数等同于： F(X[0], pre), F(X[1], X[0]), ..., F(X[n],
X[n-1])。

内置函数 [ratios](../r/ratios.html) 和 [deltas](../d/deltas.html) 也是通过用 *eachPre* 高阶函数实现。定义如下：

* function deltas(a){return a[0] -:P a}
* function ratios(a){return a[0] :P a}

## 例子

```
x=1..10;
eachPre(sub, x);
```

返回：[,1,1,1,1,1,1,1,1,1]。该用法等同于 [NULL, 2-1, ..., 10-9]

```
eachPre(sub, x,,assembleRule="U");
```

返回：(,1,1,1,1,1,1,1,1,1)

```
-:P x;
```

返回：[,1,1,1,1,1,1,1,1,1]。该用法等同于 [NULL, 2-1, ..., 10-9]

```
eachPre(+, x);
```

返回：[,3,5,7,9,11,13,15,17,19]。该用法等同于 [NULL, 2+1, ..., ]。

```
0 +:P x;
```

返回：[1,3,5,7,9,11,13,15,17,19]。该用法等同于 [1+0, 2+1, ..., ]。

```
x=1..12$3:4;
x;
```

返回：

| col1 | col2 | col3 | col4 |
| --- | --- | --- | --- |
| 1 | 4 | 7 | 10 |
| 2 | 5 | 8 | 11 |
| 3 | 6 | 9 | 12 |

```
- :P x;
```

返回：

| col1 | col2 | col3 | col4 |
| --- | --- | --- | --- |
|  | 3 | 3 | 3 |
|  | 3 | 3 | 3 |
|  | 3 | 3 | 3 |

```
eachPre(\, x, x[0]);
```

返回：

| col1 | col2 | col3 | col4 |
| --- | --- | --- | --- |
| 1 | 4 | 1.75 | 1.428571 |
| 1 | 2.5 | 1.6 | 1.375 |
| 1 | 2 | 1.5 | 1.333333 |

```
def f1(a,b){
    return (a[`x])+(a[`y])+(b[`x])+(b[`y])
}

t = table(1 2 3 as x,2 3 4 as y)
t1 = table(1 as x,2 as y)
eachPre(f1,t,t1)
```

返回：([6],8,12)

对比不同的结果组装方式。

```
tab = table(til(5) as a,`a`a`b`b`c as b)
select *, contextby({x,y->isNull(y) ? [x] : [y,x]}:P,a,b) as c from tab
//使用默认（DolphinDB）规则组装结果
a b c
- - -----
0 a [0]
1 a [0,1]
2 b [2]
3 b [2,3]
4 c 4

select *, contextby({x,y->isNull(y) ? [x] : [y,x]}:PU,a,b) as c from tab
//使用 Tuple 规则组装结果，可以发现最后一行记录的 c 列也输出一个向量
a b c
- - -----
0 a [0]
1 a [0,1]
2 b [2]
3 b [2,3]
4 c [4]
```

