# byRow

## 语法

`byRow(func, X, [Y])`

或

`func:H(X)`

或

`func:H(X, [Y])`

## 参数

**func** 是一个函数。该函数可以是向量函数（输入与输出均为等长向量），亦可为聚合函数。

**X** 是一个矩阵、表、元组、数组向量、列式元组。

**Y** 可以是矩阵、表、元组、数组向量或列式元组。

其他相关的 row 系列函数的参数说明和窗口计算规则请参考: [行计算系列（row 系列）](../themes/rowFunctions.md)

## 详情

*func* 为单目函数时，对矩阵 *X*
的每一行应用指定函数。

*func* 为双目函数时，对 *X* 和 *Y* 的每行执行 func(Xi, Yi) 。

**计算规则**

* 如果 *X/Y* 是矩阵、表或元组：byRow 首先将对象转置，然后对转置后的对象的每一列应用指定函数。

  + 当 *func* 是向量函数时，byRow 会把 *func* 的计算结果转置后输出。
  + 当 *func* 是聚合函数时，输出结果是一个向量，无需进行转置操作。特别地，当 *func*
    是以下聚合函数时，byRow 进行了优化，不会对 *X*/*Y* 进行上步的转置操作，从而提高了计算性能：sum,
    sum2, avg, min, max, count, imax, imin, imaxLast, iminLast, prod,
    std, stdp, var, varp, skew, kurtosis, any, all, corr, covar, wavg,
    wsum, beta, euclidean, dot, tanimoto。
* 如果 X/Y 是数组向量或列式元组，byRow 对 X/Y的每一行数据应用指定函数。

**返回值**

* 当 *func* 是聚合函数时，输出结果是一个向量。向量的长度与 *X/Y* 的行数相同。
* 当 *func* 是向量函数时，输出结果的形式、维度和 *X/Y* 的形式、维度相同。

注： 通过 byRow 函数，可以实现与内置 row
系列函数相同的功能，并且计算结果和性能与 row 系列函数相同。例如 byRow(sum, X) 等效于 rowSum(X)。因此 byRow
函数可以应用于所有需要进行行计算的场景中。

## 例子

入参是矩阵：

```
m=matrix([1 3 4 2,1 2 2 1])
max:H(m)
[1,3,4,2]

cummax:H(m)

col1	col2
1	1
3	3
4	4
2	2

n=matrix([11 5 9 2,8 5 3 2])
corr:H(m,n)
[,,1,]
```

入参是表：

```
qty1 = 2200 1900 2100 3200 6800 5400 1300 2500 8800
qty2 = 2100 1800  6800 5400 1300 2400 8500 4100 3200
t = table(qty1, qty2);
max:H(t)
[2200,1900,6800,5400,6800,5400,8500,4100,8800]

cummax:H(t)

qty1	qty2
2,200	2,200
1,900	1,900
2,100	6,800
3,200	5,400
6,800	6,800
5,400	5,400
1,300	8,500
2,500	4,100
8,800	8,800

qty3 = 7800 5400 5300 2500 1800 2200 3900 3100 1200
qty4 = 3200 2800 6400 8300 2300 3800 2900 1600 2900
t1 = table(qty3, qty4);
corr:H(t,t1)
[1,1,1,1,-1,-1,-1,-1,-1]
```

入参是元组：

```
tp=[1 3 4 2,1 2 2 1]
sum:H(tp)
[2,5,6,3]

cummax:H(tp)
([1,3,4,2],[1,3,4,2])

tp1=[11 23 14 21,10 12 32 21]
corr:H(tp,tp1)
[,1,-1,]
```

入参是数组向量：

```
a=array(INT[], 0, 10).append!([1 2 3, 4 5 4, 6 7 8, 1 9 10]);
sum:H(a)
[6,13,21,20]

cummax:H(a)
[[1,2,3],[4,5,5],[6,7,8],[1,9,10]]

b=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2, 86.5 52 36.5, 10.1 12.4 16.8])
corr:H(a,b)
[0.95,0.90,-0.97,0.82]
```

入参是列式元组：

```
ctp=[1 3 4 2,1 2 2 1]
ctp.setColumnarTuple!()
sum:H(ctp)
[10,6]

cummax:H(ctp)
([1,3,4,4],[1,2,2,2])

ctp1=[11 23 14 21,10 12 32 21]
ctp1.setColumnarTuple!()

corr:H(ctp,ctp1)
[0.25, 0.37]
```

```
m=matrix(1 1, 2 3, 2 1);
m;
```

| col1 | col2 | col3 |
| --- | --- | --- |
| 1 | 2 | 2 |
| 1 | 3 | 1 |

```
byRow(add{10 20 30},m);
```

| col1 | col2 | col3 |
| --- | --- | --- |
| 11 | 22 | 32 |
| 11 | 23 | 31 |

```
byRow(mode,m);
// output
[2,1]
```

```
b=array(DOUBLE[], 0, 10).append!([11.8 21.2 23.9, 83.3 90.2 78.2 86.5, 10.1 12.4 16.8])
byRow(add{100},b)
// output
[111.8 121.2 123.9,183.3 190.2 178.2 86.5,110.1 112.4 116.8]
byRow(imax,b)
// output
[2,1,2]
```

