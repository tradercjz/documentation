# eachLeft

## 语法

`eachLeft(func, X, Y, [assembleRule|consistent=false])`

`func:L(X, Y)` 或 `X <operator>:L Y` 表示不指定
*assembleRule*，使用默认值

`func:LC(X, Y)` 或 `X <operator>:LC Y` 表示指定
*assembleRule*，此例中指定为 C（Consistent）

## 参数

* **func** 是一个二元函数。
* **X** 和 **Y** 可以是向量、矩阵、表、数组向量或字典。
* **assembleRule** 可选参数，表示如何将子任务的结果合并为函数最终结果。接受一个整数或字符串作为输入，可选值如下：
  + 0 （或 "D"）：默认值，表示 DolphinDB
    规则，即根据所有子任务的结果来决定最终输出的数据类型和形式。当所有子结果具有相同的数据类型和形式时，多个标量合并为一个向量、多个向量合并为一个矩阵、多个矩阵合并为一个元组、多个字典合并为一张表；否则将所有子结果合并为一个元组输出。
  + 1（或 "C"）：表示 Consistent
    规则，即认为所有子结果的数据类型和形式都与第一个子结果相同，根据第一个子结果来选择最终结果的数据类型和形式。如果后续子任务返回的结果与第一个子任务的结果类型不一致，系统会尝试对后续结果进行类型转换。如果转换失败则抛出异常。因此，此规则只可在已知子结果的数据类型及形式一致时指定。此规则可使系统免于逐一缓存并检查每个子任务的计算结果，从而提升性能。
  + 2（或 "U"）：表示 Tuple 规则，系统不再对各子结果的类型和形式一致性进行检查，而是直接将子结果组装成一个元组输出。
  + 3（或 "K"）：表示 kdb+ 规则。与 DolphinDB 规则类似，都会根据所有子结果来决定最终结果形式。主要区别在于，kdb+
    规则下，只要有任一子任务返回向量，则最终结果必为一个元组；而在 DolphinDB
    规则下，子任务结果若均为长度相同的向量，则最终结果为一个矩阵。其他情况下，kdb+ 规则的输出与 DolphinDB 规则相同。

  注：
  + 自 2.00.15/3.00.3 版本起，新增了
    *assembleRule* 参数。该参数不仅实现了原 *consistent*
    参数的功能，还提供了更多的结果合并选项。*consistent* 是一个布尔值，默认值为 false，相当于
    *assembleRule*="D"；若为 true，则相当于
    *assembleRule*="C"。为保持兼容性，用户仍可使用 *consistent* 参数。如果同时指定
    *assemble* 和 *consistent*，将以 *consistent*
    的值为准。
  + *assembleRule* 也可在高阶函数对应的函数模式符号后指定，通过字符 D/C/U/K 表示。以
    `eachPre (:P)` 为例，形如
    `sub:PU(X)`。不指定则使用默认值 D。

## 详情

把 func 应用到 *X* 的每个元素上，即依次执行 func(X(i),Y)。

* 对于向量，X(i) 为每个元素
* 对于矩阵，X(i) 为每一列
* 对于表，X(i) 为每一行
* 对于数组向量，X(i) 为每一行
* 对于字典，X(i) 为字典的每一个 value

如果 func 支持向量操作，并且输入数据是一个向量，使用向量函数或运算符比使用 eachLeft 更为高效。

## 例子

*eachLeft* 作用于两个向量：

```
x = 4 3 2 1
y = 3 0 6;
x +:L y;
```

| 4 | 3 | 2 | 1 |
| --- | --- | --- | --- |
| 7 | 6 | 5 | 4 |
| 4 | 3 | 2 | 1 |
| 10 | 9 | 8 | 7 |

```
eachLeft(pow, x, y);
```

| 4 | 3 | 2 | 1 |
| --- | --- | --- | --- |
| 64 | 27 | 8 | 1 |
| 1 | 1 | 1 | 1 |
| 4096 | 729 | 64 | 1 |

*eachLeft* 作用于一个矩阵以及一个向量：

```
x=1..6$2:3;
x;
```

| col1 | col2 | col3 |
| --- | --- | --- |
| 1 | 3 | 5 |
| 2 | 4 | 6 |

```
x ** :L 1 1;
// output
[3,7,11]
```

*eachLeft* 作用于两个矩阵：

```
y=6..1$2:3;
y;
```

| col1 | col2 | col3 |
| --- | --- | --- |
| 6 | 4 | 2 |
| 5 | 3 | 1 |

```
z = x **:L y;
z;

// output
(#0 #1 #2
-- -- --
16 10 4
,#0 #1 #2
-- -- --
38 24 10
,#0 #1 #2
-- -- --
60 38 16
)
```

```
typestr z;
// output
ANY VECTOR
```

*eachLeft* 作用于一个字典和一个向量：

```
d=dict(`a`b`c, [[1, 2, 3],[4, 5, 6], [7, 8, 9]])
eachLeft(add,d,10 20 30)
// output
a->[11,22,33]
b->[14,25,36]
c->[17,28,39]
```

