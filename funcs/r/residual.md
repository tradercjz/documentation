# residual

## 语法

`residual(Y,X,params,[intercept=true])`

## 参数

**Y** 是因变量；**X** 是自变量。

**Y** 是一个向量；**X** 是一个矩阵、表或元组。当 *X* 是矩阵时，如果行数等于 *Y* 的长度，*X*
的每一列都是一个因子；如果行数不等于 *Y* 的长度，并且如果列数等于 *Y* 的长度，*X* 的每一行都是一个因子。

**params** 表示回归模型的系数。

**intercept** 是一个布尔变量，表示是否包含回归中的截距。默认值是 true。当它为 true 时，系统自动给 *X* 添加一列 "1"
以生成截距。

## 详情

返回对 *X* 和 *Y* 计算最小二乘回归结果的残差。

注： 对于内存表，[ols](../o/ols.md) 和 [wls](../w/wls.md) 设置
*mode*=2，即可获得残差。对于分布式表，只能通过此函数计算残差。

## 例子

例1

```
x1=1 3 5 7 11 16 23
x2=2 8 11 34 56 54 100
y=0.1 4.2 5.6 8.8 22.1 35.6 77.2

params=ols(y, x1);
residual(y,x1,params)
// output
[6.634188034188036,3.976923076923078,-1.380341880341881,-4.937606837606838,-5.152136752136756,-8.545299145299146,9.404273504273504]

params1=ols(y, (x1,x2),false);
residual(y,(x1,x2),params1,false)
// output
[-1.941530853763632,-2.556479729553295,-4.923597852949359,-11.809587658969416,-11.098921251860737,-4.0152525111045,13.183836820351686]

x=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);
p1=ols(1..5, x);
residual(1..5, x,p1);
// output
[-0.474770642201834,0.268348623853214,-0.123853211009174,0.598623853211011,-0.268348623853205]
```

例2

```
x1 = 10 20 30 40 50
x2 = 5 15 25 35 45
x3 = 3 6 9 12 15
factor0 = 10.7 22.2 29.6 43.4 48.9

t = table(x1, x2, x3, factor0)

x = `x + string(1..3)
residual = makeCall(member, makeCall(ols, sqlCol(`factor0), makeUnifiedCall(matrix, sqlCol(x)), 1, 2), "Residual")
sql(residual, t).eval()
```

| member |
| --- |
| -0.74 |
| 1 |
| -1.36 |
| 2.68 |
| -1.58 |

