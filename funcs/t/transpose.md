# transpose

## 语法

`transpose(X)`

别名：`flip(X)`

## 参数

**X** 是一个元组、矩阵、表或字典、数组向量或列式元组。

* 如果 X 是元组，则元组中的元素须为长度相等的向量。
* 如果 *X* 是数组向量或列式元组，则每行包含的元素个数必须相等。

## 详情

本函数用于转置输入数据 *X*：

* 如果 *X* 是一个元组，`transpose` 函数返回的是一个与
  *X* 中每个向量长度相同的元组，返回结果中的第 n 个元素是由 *X* 中每个向量的第 n 个值组成的向量。
* 如果 *X* 是一个矩阵，`transpose` 函数返回 *X*
  的转置矩阵。
* 如果 *X* 是一个表，`transpose` 函数把表 *X*
  转换为一个有序字典（从 2.00.9 版本开始支持有序字典），表中的列名为 key，每列的值为 value。
* 如果 *X* 是一个字典，且 key 是 STRING 类型，`transpose` 函数把字典 *X*
  转换为一个表
  + 当value 为标量或等长向量时，表的列名为字典的 key 值，每列的值为对应 value。
  + 当 value 为字典时，表中第一列的列名为 ”key“，其值为 *X* 的 key 值；后续列的列名为 *X*中第一个子字典的键，其值为各子字典中对应的值。若某个子字典中不包含某键，则表中对应值为空值。

  注： 不支持将包含超过 32,767 个键的字典转换为表。
* 如果 *X* 是一个数组向量或列式元组，transpose 函数将 *X* 的行和列转置。

## 例子

例1. *X* 是一个元组。

```
x=(`A`B`C,1 2 3);
x.transpose();
// output：(("A",1),("B",2),("C",3))
```

例2. *X* 是一个矩阵。

```
x=1..6 $ 3:2;
x;
```

| #0 | #1 |
| --- | --- |
| 1 | 4 |
| 2 | 5 |
| 3 | 6 |

```
transpose x;
```

| #0 | #1 | #2 |
| --- | --- | --- |
| 1 | 2 | 3 |
| 4 | 5 | 6 |

例3. *X* 是一个表。

```
timestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]
sym = `C`MS`MS`MS`IBM`IBM`C`C`C
price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29
qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800
t = table(timestamp, sym, qty, price);
t;
```

| timestamp | sym | qty | price |
| --- | --- | --- | --- |
| 09:34:07 | C | 2200 | 49.6 |
| 09:36:42 | MS | 1900 | 29.46 |
| 09:36:51 | MS | 2100 | 29.52 |
| 09:36:59 | MS | 3200 | 30.02 |
| 09:32:47 | IBM | 6800 | 174.97 |
| 09:35:26 | IBM | 5400 | 175.23 |
| 09:34:16 | C | 1300 | 50.76 |
| 09:34:26 | C | 2500 | 50.32 |
| 09:38:12 | C | 8800 | 51.29 |

```
transpose(t);
/*
timestamp->[09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]
sym->[C,MS,MS,MS,IBM,IBM,C,C,C]
qty->[2200,1900,2100,3200,6800,5400,1300,2500,8800]
price->[49.6,29.46,29.52,30.02,174.97,175.23,50.76,50.32,51.29]
*/
```

例4. *X* 是一个字典。

```
z=dict(`id`val,[`a`b`c,1 2 3]);
z;
/*
val->[1,2,3]
id->[a,b,c]
*/
transpose(z);
```

| val | id |
| --- | --- |
| 1 | a |
| 2 | b |
| 3 | c |

```
//当字典的 value 既包含标量又包含向量时，transpose 会重复标量的值以匹配向量的长度
z1=dict(`id`val,[`a,1 2 3]);
z1;
transpose(z1)
```

|  |  |
| --- | --- |
| **val** | **id** |
| 1 | a |
| 2 | a |
| 3 | a |

例5. *X* 是一个嵌套字典。

```
d = {'tag1':{'val1':2,'val2':6},'tag2':{'val2':1, 'val3':3}}
d
/*
tag1->
    val1->2
    val2->6

tag2->
    val2->1
    val3->3
*/
transpose(d)
```

| key | val1 | val2 |
| --- | --- | --- |
| tag1 | 2 | 6 |
| tag2 |  | 1 |

从结果可以看出，转置后的表的列包括 "key" 和第一个子字典的键（val1，val2），“key” 列的值对应字典 `d` 的键，val1
和 val2 列的值对应子字典中的相应值。由于 tag2 对应的子字典不包含键 val1，故表中对应的值为空值，且键 val3 对应的值会被丢弃。

