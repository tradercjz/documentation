# fmin

## 语法

`fmin(func, X0, [xtol=0.0001],
[ftol=0.0001], [maxIter], [maxFun])`

## 详情

使用 Nelder-Mead 单纯形算法找到目标函数的最小值。

注意：该算法只使用函数值，不使用一阶导数或二阶导数。

## 参数

**func** 函数名，表示需要最小化的目标函数。注意：函数返回值须是数值标量类型。

**X0** 数值类型的标量或向量，表示使目标函数最小化的参数的初始猜测。

**xtol** 可选参数，正数值标量，表示在迭代过程中 `xopt` 之间可接受的收敛的绝对误差。默认值为 0.0001。

**ftol** 可选参数，正数值标量，表示在迭代过程中 `func(xopt)` 的绝对误差可接受的收敛标准。默认值为
0.0001。

**maxIter** 可选参数，非负整数标量，表示执行的最大迭代次数。

**maxFun** 可选参数，非负整数标量，表示最大目标函数调用次数。

## **返回值**

返回一个字典，包含以下成员：

* xopt：浮点数向量，使目标函数最小化的参数值。
* fopt：浮点数标量，目标函数最小值。fopt=func(xopt)。
* iterations：整数标量，优化过程中执行的总迭代数。
* fcalls：整数标量，优化过程中目标函数的调用次数。
* warnFlag：整数标量，有三个可能值：

  + 0：表示成功执行算法全过程。
  + 1：表示已达最大目标函数调用次数，算法停止执行。
  + 2：表示已达最大迭代次数，算法停止执行。

## 例子

下例中自定义一个 f(x) 函数，使用 Nelder-Mead 单纯形算法找到其最小值。

```
def f(x) {return x*x}
fmin(f, 1)
/* Ouput:
xopt->[-8.881784197001252E-16]
fopt->7.888609052210119E-31
iterations->17
fcalls->34
warnFlag->0
*/
```

