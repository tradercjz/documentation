# asFreq

## 语法

`asFreq(X, rule, [closed], [label],
[origin='start_day'])`

## 详情

转换给定数据的时间频率。与 [resample](../r/resample.md)
函数不同，该函数不可使用聚合函数对数据进行处理。

## 参数

**X** 是有时间类型索引的矩阵（由 `setIndexedMatrix!` 创建）或序列（由
`setIndexedSeries!` 创建）。

**rule** 可以是一个字符串，可取以下值，亦可为一个时间类型的向量。

| Y 参数取值 | 对应 DolphinDB 函数 |
| --- | --- |
| "B" | businessDay |
| "W" | weekEnd |
| "WOM" | weekOfMonth |
| "LWOM" | lastWeekOfMonth |
| "M" | monthEnd |
| "MS" | monthBegin |
| "BM" | businessMonthEnd |
| "BMS" | businessMonthBegin |
| "SM" | semiMonthEnd |
| "SMS" | semiMonthBegin |
| "Q" | quarterEnd |
| "QS" | quarterBegin |
| "BQ" | businessQuarterEnd |
| "BQS" | businessQuarterBegin |
| "REQ" | fy5253Quarter |
| "A" | yearEnd |
| "AS" | yearBegin |
| "BA" | businessYearEnd |
| "BAS" | businessYearBegin |
| "RE" | fy5253 |
| "D" | date |
| "H" | hourOfDay |
| "min" | minuteOfHour |
| "S" | secondOfMinute |
| "L" | millisecond |
| "U" | microsecond |
| "N" | nanosecond |

上述字符串亦可配合使用数字（必须为正整数），例如 "2M" 表示频率为每两个月月末。此外，*rule*
也可以是交易日历标识（国外交易所的 ISO
Code、国内交易所简称或自定义交易日历名称），以便基于交易日历进行计算。交易日历也可以配合使用数字，表示多个交易日，此时只能指定由4个大写字母组成的交易日历标识。例如：“2XSHG”，表示上海证券交易所每两个交易日。

**closed** 字符串，表示分组区间哪一个边界是闭合的。

* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*closed* 的默认取值为
  'right' ，否则，*closed* 的默认取值为 'left'。
* *origin* 取 'end' 或者 'end\_day' 时，*closed* 的默认值为 'right'。

**label** 字符串，表示将分组区间的哪一个边界作为 *label* 输出。

* *rule* 为 'M', 'A', 'Q', 'BM', 'BA', 'BQ' 和 'W' 时，*label* 的默认取值为
  'right' ，否则，*label* 的默认取值为 'left'。
* *origin* 取 'end' 或者 'end\_day' 时，*label* 的默认值为 'right'。

**origin** 字符串或和 *X* 具有相同时间类型的标量，表示基于时间戳调整分组。取值为 'epoch', start',
'start\_day', 'end', 'end\_day' 或自定义的时间对象，默认值为 'start\_day'。

* 'epoch'：分组起始点为1970-01-01。
* 'start'：分组起始点为时间序列的第一个值。
* 'start\_day'：分组起始点是时间序列的第一个值对应日期的午夜零点。
* 'end'：分组起始点是时间序列的最后一个时间戳。
* 'end\_day'：分组起始点是时间序列的最后一个时间戳对应日期的午夜24点（即下一日的零点）。

## 例子

```
index = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.31, 2000.04.16, 2000.05.06, 2000.08.31]
s = indexedSeries(index, 1..8)
s
```

| lable | 0 |
| --- | --- |
| 2000.01.01 | 1 |
| 2000.01.31 | 2 |
| 2000.02.15 | 3 |
| 2000.02.20 | 4 |
| 2000.03.31 | 5 |
| 2000.04.16 | 6 |
| 2000.05.06 | 7 |
| 2000.08.31 | 8 |

```
s.asFreq("M")
```

| lable | 0 |
| --- | --- |
| 2000.01.31 | 2 |
| 2000.02.29 |  |
| 2000.03.31 | 5 |
| 2000.04.30 |  |
| 2000.05.31 |  |
| 2000.06.30 |  |
| 2000.07.31 |  |
| 2000.08.31 | 8 |

```
s.asFreq("2M")
```

| lable | 0 |
| --- | --- |
| 2000.01.31 | 2 |
| 2000.03.31 | 5 |
| 2000.05.31 |  |
| 2000.07.31 |  |

```
index = [2020.01.01, 2020.01.03, 2020.01.06]
s = indexedSeries(index, 1..3)
s
```

| lable | 0 |
| --- | --- |
| 2020.01.01 | 1 |
| 2020.01.03 | 2 |
| 2020.01.06 | 3 |

```
s.asFreq("D")
```

| lable | 0 |
| --- | --- |
| 2020.01.01 | 1 |
| 2020.01.02 |  |
| 2020.01.03 | 2 |
| 2020.01.04 |  |
| 2020.01.05 |  |
| 2020.01.06 | 3 |

```
s.asFreq("2D")
```

| lable | 0 |
| --- | --- |
| 2020.01.01 | 1 |
| 2020.01.03 | 2 |
| 2020.01.05 |  |

```
index = temporalAdd(2022.10.01 23:30:00,7*(0..8),`m)
s = indexedSeries(index, 3*(0..8))
s.asFreq("8min")
```

| label | col1 |
| --- | --- |
| 2022.10.01T23:28:00 |  |
| 2022.10.01T23:36:00 |  |
| 2022.10.01T23:44:00 | 6 |
| 2022.10.01T23:52:00 |  |
| 2022.10.02T00:00:00 |  |
| 2022.10.02T00:08:00 |  |
| 2022.10.02T00:16:00 |  |
| 2022.10.02T00:24:00 |  |

```
s.asFreq(rule=`8min,closed=`right)
```

| label | col1 |
| --- | --- |
| 2022.10.01T23:36:00 |  |
| 2022.10.01T23:44:00 | 6 |
| 2022.10.01T23:52:00 |  |
| 2022.10.02T00:00:00 |  |
| 2022.10.02T00:08:00 |  |
| 2022.10.02T00:16:00 |  |
| 2022.10.02T00:24:00 |  |
| 2022.10.02T00:32:00 |  |

```
s.asFreq(rule=`8min,closed=`right,origin=`end)
```

| label | col1 |
| --- | --- |
| 2022.10.01T23:30:00 | 0 |
| 2022.10.01T23:38:00 |  |
| 2022.10.01T23:46:00 |  |
| 2022.10.01T23:54:00 |  |
| 2022.10.02T00:02:00 |  |
| 2022.10.02T00:10:00 |  |
| 2022.10.02T00:18:00 |  |
| 2022.10.02T00:26:00 | 24 |

