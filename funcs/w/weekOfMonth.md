# weekOfMonth

## 语法

`weekOfMonth(X, [week=0], [weekday=0], [offset],
[n=1])`

## 参数

**X** 可以是 DATE, DATETIME, TIMESTAMP 或 NANOTIMESTAMP
类型的标量或向量。

**week** 是0到3的整数，表示第几个星期。默认值为0。

**weekday** 是0到6之间的整数，表示星期编号。0表示星期一，1表示星期二，... ，6表示星期日。默认值为0。

**offset** 是与 *X* 类型相同的标量，并且它必须小于等于 *X*
中的最小值。它是一个可选参数。如果没有指定，*offset* 默认为 *X* 中的最小值。

**n** 是一个正整数。它是一个可选参数，默认值为1。

## 详情

返回 *X* 所在月份或上一个月中第 *week* 个 *weekday* 对应的日期。假设
*X* 所在月份的第 *week* 个 *weekday* 对应日期为 d：

如果 *X* < *d* ，*weekOfMonth* 函数返回 *X* 的上一个月中第 *week* 个
*weekday* 对应的日期。

如果 *X* >= *d* ，*weekOfMonth* 函数返回 *X* 所在月份的第 *week* 个
*weekday* 对应的日期。

如果指定了 *offset* ，表示从 *offset* 开始，结果每隔 *n* 个月更新一次。注意，只有当 *n*
>1时，*offset* 才会生效。

## 例子

```
weekOfMonth(2019.11.01,2,4);
// output
2019.10.18
//2019年11月的第三个星期五为2019.11.15，2019.11.01在2019.11.15之前，因此返回2019年10月的第三个星期五

weekOfMonth(2019.11.20,2,4);
2019.11.15

date=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28
time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]
sym = take(`MSFT,10)
price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38
qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500
t1 = table(date, time, sym, qty, price);

select avg(price),sum(qty) from t1 group by weekOfMonth(date,3,4,2012.01.01,2);
```

| weekOfMonth\_date | avg\_price | sum\_qty |
| --- | --- | --- |
| 2011.12.23 | 39.53 | 4100 |
| 2012.02.24 | 29.77 | 5300 |
| 2012.04.27 | 175.1 | 12200 |
| 2012.06.22 | 50.54 | 3800 |
| 2012.08.24 | 51.29 | 8800 |
| 2012.10.26 | 52.38 | 4500 |

